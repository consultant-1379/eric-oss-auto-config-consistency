/*******************************************************************************
 * COPYRIGHT Ericsson 2023 - 2024
 *
 *
 *
 * The copyright to the computer program(s) herein is the property of
 *
 * Ericsson Inc. The programs may be used and/or copied only with written
 *
 * permission from Ericsson Inc. or in accordance with the terms and
 *
 * conditions stipulated in the agreement/contract under which the
 *
 * program(s) have been supplied.
 ******************************************************************************/

package com.ericsson.oss.apps.controller;

import static com.ericsson.oss.apps.util.Constants.ATTACHMENT;
import static com.ericsson.oss.apps.util.Constants.CSV_CONTENT_TYPE;
import static com.ericsson.oss.apps.util.Constants.CSV_FILENAME_TEMPLATE;
import static com.ericsson.oss.apps.util.Constants.DATABASE_OPERATION_FAILED;
import static com.ericsson.oss.apps.util.Constants.FAILED_TO_CREATE_RULESET;
import static com.ericsson.oss.apps.util.Constants.FAILED_TO_UPDATE_RULESET;
import static com.ericsson.oss.apps.util.Constants.PROVIDE_A_VALID_RULESET_ID;
import static com.ericsson.oss.apps.util.Constants.UUID_ID_ERROR;

import java.io.IOException;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.dao.DataAccessException;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.TransactionException;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.ericsson.oss.apps.api.RulesetsApi;
import com.ericsson.oss.apps.api.model.EaccRulesetMetadata;
import com.ericsson.oss.apps.model.RuleSet;
import com.ericsson.oss.apps.service.ExecutionService;
import com.ericsson.oss.apps.service.JobService;
import com.ericsson.oss.apps.service.RuleSetService;
import com.ericsson.oss.apps.service.ValidationService;
import com.ericsson.oss.apps.util.ValidationObject;
import com.ericsson.oss.apps.validation.ModelManagerImpl;
import com.ericsson.oss.apps.validation.RuleValidationException;
import com.opencsv.exceptions.CsvRequiredFieldEmptyException;

import lombok.extern.slf4j.Slf4j;

/**
 * Implementation of RulesetsApi generated by open api generator.
 */
@Slf4j
@RestController
public class RulesetController implements RulesetsApi {

    private final RuleSetService ruleSetService;
    private final JobService jobService;
    private final ExecutionService executionService;
    private final ValidationService validationService;
    private final ModelManagerImpl modelManager;

    @Autowired
    public RulesetController(final RuleSetService ruleSetService, final JobService jobService, final ExecutionService executionService,
            final ValidationService validationService, final ModelManagerImpl modelManager) {
        this.ruleSetService = ruleSetService;
        this.jobService = jobService;
        this.executionService = executionService;
        this.validationService = validationService;
        this.modelManager = modelManager;
    }

    @Override
    public ResponseEntity<EaccRulesetMetadata> createRuleset(
            @RequestParam("rulesetName") final String rulesetName,
            @RequestPart("fileName") final MultipartFile file) {
        log.info("POST /rulesets REST interface is invoked.");

        final ValidationObject validationObject = validationService.validateRulesetName(rulesetName);
        if (!validationObject.getValidated()) {
            log.error(validationObject.getDetails());
            throw new ControllerDetailRuleException(
                    validationObject.getHttpStatus(),
                    validationObject.getDetails(),
                    validationObject.getTitle());
        }

        log.debug("Format of RuleSet name validated.");
        try {
            if (ruleSetService.existsByName(rulesetName)) {
                throw new ControllerDetailRuleException(HttpStatus.BAD_REQUEST, "Use a unique Ruleset name.",
                        "Failed to create ruleset. Ruleset with provided name already exists.");
            }

            checkModelIsReadyForValidation();

            final RuleSet ruleSet = ruleSetService.createRulesetFromCsv(rulesetName, file);
            final EaccRulesetMetadata eaccRulesetMetadata = ruleSetService.createEaccRulesetMetadata(ruleSet);
            final URI locationUri = URI.create(eaccRulesetMetadata.getUri());
            log.info("Ruleset created successfully with URI: {}", locationUri);
            return ResponseEntity.created(locationUri).body(eaccRulesetMetadata);
        } catch (final IOException e) {
            log.error(FAILED_TO_CREATE_RULESET, e);
            final ControllerDetailException exception = new ControllerDetailException(HttpStatus.INTERNAL_SERVER_ERROR, FAILED_TO_CREATE_RULESET);
            exception.addSuppressed(e);
            throw exception; //NOPMD
        } catch (final CsvRequiredFieldEmptyException e) {
            log.error(FAILED_TO_CREATE_RULESET, e);
            final ControllerDetailRuleException exception = new ControllerDetailRuleException(HttpStatus.BAD_REQUEST,
                    "Fill in all required fields with the appropriate information.",
                    "File cannot contain missing values and column headers must match the Rule model.");
            exception.addSuppressed(e);
            throw exception; //NOPMD
        } catch (final RuleValidationException e) {
            log.error(FAILED_TO_CREATE_RULESET, e);
            final ControllerDetailRuleException exception = new ControllerDetailRuleException(HttpStatus.BAD_REQUEST,
                    "Ruleset cannot contain any invalid MO types, attributes or values.",
                    "Problems found in ruleset.", e.getRuleValidationErrors());
            exception.addSuppressed(e);
            throw exception; //NOPMD
        } catch (final DataAccessException | TransactionException e) {
            log.error(FAILED_TO_CREATE_RULESET, e);
            final ControllerDetailException exception = new ControllerDetailException(HttpStatus.INTERNAL_SERVER_ERROR,
                    DATABASE_OPERATION_FAILED, FAILED_TO_CREATE_RULESET);
            exception.addSuppressed(e);
            throw exception; //NOPMD
        }
    }

    @Override
    public ResponseEntity<List<EaccRulesetMetadata>> listRulesets() {
        log.info("GET /rulesets REST interface is invoked.");
        try {
            return new ResponseEntity<>(ruleSetService.getAllRulesetMetadata(), HttpStatus.OK);
        } catch (final DataAccessException | TransactionException e) {
            log.error("Failed to get rulesets.", e);
            final ControllerDetailException exception = new ControllerDetailException(HttpStatus.INTERNAL_SERVER_ERROR,
                    DATABASE_OPERATION_FAILED, "Failed to get rulesets.");
            exception.addSuppressed(e);
            throw exception; //NOPMD
        } catch (final Exception e) {
            log.error("Error getting RuleSet Metadata.", e);
            final ControllerDetailException exception = new ControllerDetailException(HttpStatus.INTERNAL_SERVER_ERROR,
                    "Failed to get all RuleSet metadata.");
            exception.addSuppressed(e);
            throw exception; //NOPMD
        }
    }

    @Override
    public ResponseEntity<EaccRulesetMetadata> updateRuleset(final String id, final MultipartFile fileName, final String accept,
            final String contentType) {
        log.info("PUT /rulesets REST interface is invoked.");

        final UUID uuid = parseUuidFromString(id, true);
        log.debug("Format of UUID validated.");

        try {
            if (!ruleSetService.existsById(uuid)) {
                throw new ControllerDetailException(HttpStatus.NOT_FOUND, "Enter a valid Ruleset ID.",
                        "Failed to find ruleset. Ruleset doesn't exist.");
            }
            final String ruleSetName = ruleSetService.getRulesetNameFromId(uuid);

            if (executionService.isRulesetInUse(ruleSetName)) {
                throw ControllerDetailException.builder().withStatus(HttpStatus.CONFLICT)
                        .withTitle("Cannot update ruleset as it is used by an ongoing execution.")
                        .withDetail("Ruleset in use.").build();
            }

            checkModelIsReadyForValidation();

            final RuleSet updatedRuleSet = ruleSetService.updateRulesetFromCsv(uuid, fileName);
            final EaccRulesetMetadata updatedMetadata = ruleSetService.createEaccRulesetMetadata(updatedRuleSet);
            log.info("Ruleset with id: {} updated successfully", id);
            return new ResponseEntity<>(updatedMetadata, HttpStatus.OK);
        } catch (final CsvRequiredFieldEmptyException e) {
            log.error(FAILED_TO_UPDATE_RULESET, e);
            final ControllerDetailRuleException exception = new ControllerDetailRuleException(HttpStatus.BAD_REQUEST,
                    "Fill in all required fields with the appropriate information",
                    "File cannot contain null values and column headers must match the Rule model");
            exception.addSuppressed(e);
            throw exception; //NOPMD
        } catch (final IOException e) {
            log.error(FAILED_TO_UPDATE_RULESET, e);
            final ControllerDetailException exception = new ControllerDetailException(HttpStatus.INTERNAL_SERVER_ERROR, "Failed to read InputStream",
                    FAILED_TO_UPDATE_RULESET);
            exception.addSuppressed(e);
            throw exception; //NOPMD
        } catch (final RuleValidationException e) {
            log.error(FAILED_TO_UPDATE_RULESET, e);
            final ControllerDetailRuleException exception = new ControllerDetailRuleException(HttpStatus.BAD_REQUEST,
                    "Ruleset cannot contain any invalid MO types, attributes or values.",
                    "Problems found in ruleset.", e.getRuleValidationErrors());
            exception.addSuppressed(e);
            throw exception; //NOPMD
        } catch (final DataAccessException | TransactionException e) {
            log.error(FAILED_TO_UPDATE_RULESET, e);
            final ControllerDetailException exception = new ControllerDetailException(HttpStatus.INTERNAL_SERVER_ERROR,
                    DATABASE_OPERATION_FAILED, FAILED_TO_UPDATE_RULESET);
            exception.addSuppressed(e);
            throw exception; //NOPMD
        }
    }

    private void checkModelIsReadyForValidation() {
        if (!modelManager.isModelValidationReady()) {
            log.error("Model Discovery was not yet successful and therefore cannot validate the ruleset. Try again later.");
            throw new ControllerDetailException(HttpStatus.SERVICE_UNAVAILABLE,
                    "Model Discovery has not yet completed and therefore cannot validate the ruleset.",
                    "Failed to create/update ruleset. Service not ready.");
        }
    }

    @Override
    public ResponseEntity<Void> deleteRuleset(final String id, final String accept) {
        log.info("DELETE /rulesets REST interface is invoked.");
        final UUID uuid = parseUuidFromString(id);
        log.debug("Format of UUID validated.");

        final String rulesetName;

        try {
            rulesetName = ruleSetService.getRulesetNameFromId(uuid);

            if (jobService.isRuleSetInUse(rulesetName)) {
                throw new ControllerDetailException(HttpStatus.CONFLICT,
                        "Only Rulesets not associated with a Job configuration can be deleted.",
                        "Ruleset with provided ID is used in a Job configuration.");
            }

            ruleSetService.deleteRulesetById(uuid);
        } catch (final IllegalArgumentException e) {
            throw buildExceptionForRulesetDoesNotExist(e);
        } catch (final DataAccessException | TransactionException e) {
            log.error("Failed to delete ruleset.", e);
            final ControllerDetailException exception = new ControllerDetailException(HttpStatus.INTERNAL_SERVER_ERROR,
                    DATABASE_OPERATION_FAILED, "Failed to delete ruleset.");
            exception.addSuppressed(e);
            throw exception; //NOPMD
        }

        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    @Override
    public ResponseEntity<Resource> getRuleset(final String id, final String accept) {
        final UUID uuid = parseUuidFromString(id);
        log.debug("Format of UUID validated.");
        final ByteArrayResource resource;
        try {
            if (!ruleSetService.existsById(uuid)) {
                throw new ControllerDetailException(HttpStatus.NOT_FOUND,
                        "Enter a valid Ruleset ID.", "Failed to find ruleset. Ruleset doesn't exist.");
            }

            resource = ruleSetService.createCsvFromRuleset(uuid);
        } catch (final IOException e) {
            log.error("Failed to create CSV from rules for ID provided.", e);
            final ControllerDetailException exception = new ControllerDetailException(HttpStatus.INTERNAL_SERVER_ERROR,
                    "Failed to read InputStream", "Error parsing ID. Provided ID is invalid.");
            exception.addSuppressed(e);
            throw exception; //NOPMD
        } catch (final DataAccessException | TransactionException e) {
            log.error("Failed to get ruleset.", e);
            final ControllerDetailException exception = new ControllerDetailException(HttpStatus.INTERNAL_SERVER_ERROR,
                    DATABASE_OPERATION_FAILED, "Failed to get ruleset.");
            exception.addSuppressed(e);
            throw exception; //NOPMD
        }

        if (log.isDebugEnabled()) {
            log.debug("CSV created from RuleSet: {}", new String(resource.getByteArray(), StandardCharsets.UTF_8));
        }
        final HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(CSV_CONTENT_TYPE));
        headers.setContentDisposition(ContentDisposition.builder(ATTACHMENT).filename(String.format(CSV_FILENAME_TEMPLATE, id)).build());

        return ResponseEntity.ok()
                .headers(headers)
                .body(resource);
    }

    private UUID parseUuidFromString(final String id) {
        return parseUuidFromString(id, false);
    }

    private UUID parseUuidFromString(final String id, final boolean throwRuleException) {
        final UUID uuid;
        try {
            uuid = UUID.fromString(id);
        } catch (final IllegalArgumentException e) {
            log.error("Error parsing ID. Provided ID is invalid.", e);
            final ControllerDetailException exception;
            if (throwRuleException) {
                exception = new ControllerDetailRuleException(
                        HttpStatus.BAD_REQUEST,
                        PROVIDE_A_VALID_RULESET_ID,
                        UUID_ID_ERROR);
            } else {
                exception = new ControllerDetailException(
                        HttpStatus.BAD_REQUEST,
                        PROVIDE_A_VALID_RULESET_ID,
                        UUID_ID_ERROR);
            }
            exception.addSuppressed(e);
            throw exception; //NOPMD
        }
        return uuid;
    }

    public ControllerDetailException buildExceptionForRulesetDoesNotExist(final Exception e) {
        log.error("Ruleset with provided ID does not exist.", e);
        final ControllerDetailException exception = new ControllerDetailException(HttpStatus.NOT_FOUND, PROVIDE_A_VALID_RULESET_ID,
                "Ruleset with provided ID does not exist.");
        exception.addSuppressed(e);
        return exception;
    }

}
